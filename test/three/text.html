<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body {
                    margin: 0;
                    overflow: hidden;
                    /* 隐藏body窗口区域滚动条 */
                }
		</style>
	</head>
	<body>
        <div id="container"></div>
        <script src="../../three/three/build/three.js"></script>
        <script src="../../three/three/examples/js/controls/OrbitControls.js"></script>
		<script>
                        /**
                * 创建场景对象Scene
                */
                var scene = new THREE.Scene();

                // var geometry = new THREE.PlaneGeometry(204, 102); //矩形平面
                // var geometry = new THREE.BoxGeometry(60,60,60);
                var geometry = new THREE.PlaneGeometry(1000,1000);
                var textureTree = new THREE.TextureLoader().load("rain.png");
                // 批量创建表示雨滴的精灵模型
                for (let i = 0; i < 400; i++) {
                var spriteMaterial = new THREE.SpriteMaterial({
                    map:textureTree,//设置精灵纹理贴图
                });
                // 创建精灵模型对象
                var sprite2 = new THREE.Sprite(spriteMaterial);
                scene.add(sprite2);
                // 控制精灵大小,
                sprite2.scale.set(8, 10, 1); //// 只需要设置x、y两个分量就可以
                var k1 = Math.random() - 0.5;
                var k2 = Math.random() - 0.5;
                var k3 = Math.random() - 0.5;
                // 设置精灵模型位置，在整个空间上上随机分布
                sprite2.position.set(200 * k1, 200*k3, 200 * k2)
                }
                function render() {
                // 每次渲染遍历雨滴群组，刷新频率30~60FPS，两帧时间间隔16.67ms~33.33ms
                // 每次渲染都会更新雨滴的位置，进而产生动画效果
                var group = new THREE.Group();
// 批量创建雨滴精灵模型
for (let i = 0; i < 400; i++) {group.add(sprite);
}
scene.add(group);//雨滴群组插入场景中
                group.children.forEach(sprite => {
                    // 雨滴的y坐标每次减1
                    sprite.position.y -= 1;
                    if (sprite.position.y < 0) {
                    // 如果雨滴落到地面，重置y，从新下落
                    sprite.position.y = 200;
                    }
                });
                renderer.render(scene, camera); //执行渲染操作
                requestAnimationFrame(render);//请求再次执行渲染函数render，渲染下一帧
                }
                // // var geometry = new THREE.PlaneGeometry(128, 128); //矩形平面
                // /**
                // * 创建纹理对象的像素数据
                // // */
                // // var width = 120; //纹理宽度
                // // var height = 120; //纹理高度
                // // var size = width * height; //像素大小
                // // var data = new Uint8Array(size * 3); //size*3：像素在缓冲区占用空间
                // // for (let i = 0; i < size * 3; i += 3) {
                // // // 随机设置RGB分量的值
                // // data[i] = 255 * Math.random()
                // // data[i + 1] = 255 * Math.random()
                // // data[i + 2] = 255 * Math.random()
                // // }
                // // // 创建数据文理对象   RGB格式：THREE.RGBFormat
                // // var texture = new THREE.DataTexture(data, width, height, THREE.RGBFormat);
                // // texture.needsUpdate = true; //纹理更新
                // // //打印纹理对象的image属性
                // // // console.log(texture.image);

                // // var material = new THREE.MeshPhongMaterial({
                // // map: texture, // 设置纹理贴图
                // // }); //材质对象Material
                // // var mesh = new THREE.Mesh(geometry, material);
                var textureLoader = new THREE.TextureLoader();
                var texture = textureLoader.load('glass.jpg');
                var material = new THREE.MeshLambertMaterial({
                    map:texture,
                });
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                // // // // uv两个方向纹理重复数量
                // // // texture.offset = new THREE.Vector2(0.2,0.5);
                texture.repeat.set(2,2);
                // // var material2 = new THREE.MeshPhongMaterial({
                // //     color:0xffff3f,
                // // });
                // // var materialArr = [material1,material2,material1,material1,material1,material1];
                var mesh = new THREE.Mesh(geometry,material);
                scene.add(mesh);
                mesh.rotateX(-Math.PI/2);
              // TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理
                // var textureLoader = new THREE.TextureLoader();
                // // 加载法线贴图
                // var textureNormal = textureLoader.load('faxian.jpg');
                // var material = new THREE.MeshPhongMaterial({
                // color: 0xff0000,
                // normalMap: textureNormal, //法线贴图
                // //设置深浅程度，默认值(1,1)。
                // normalScale: new THREE.Vector2(3, 3),
                // }); //材质对象Material
                // var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh
                // var texture = new THREE.TextureLoader().load("m.png");
                // // 创建精灵材质对象SpriteMaterial
                // var spriteMaterial = new THREE.SpriteMaterial({
                // color:0xff00ff,//设置精灵矩形区域颜色
                // rotation:Math.PI/4,//旋转精灵对象45度，弧度值
                // map: texture,//设置精灵纹理贴图
                // });
                // // 创建精灵模型对象，不需要几何体geometry参数
                // var sprite = new THREE.Sprite(spriteMaterial);
                // scene.add(sprite);
                // // 控制精灵大小，比如可视化中精灵大小表征数据大小
                // sprite.scale.set(10, 10, 1); //// 只需要设置x、y两个分量就可以
                // // scene.add(mesh);
                var textureTree = new THREE.TextureLoader().load("tree.png");
                // 批量创建表示一个树的精灵模型
                for (let i = 0; i < 100; i++) {
                var spriteMaterial = new THREE.SpriteMaterial({
                    map:textureTree,//设置精灵纹理贴图
                });
                // 创建精灵模型对象
                var sprite = new THREE.Sprite(spriteMaterial);
                scene.add(sprite);
                // 控制精灵大小,
                sprite.scale.set(100, 100, 1); //// 只需要设置x、y两个分量就可以
                var k1 = Math.random() - 0.5;
                var k2 = Math.random() - 0.5;
                // 设置精灵模型位置，在xoz平面上随机分布
                sprite.position.set(1000 * k1, 50, 1000 * k2)
                }
                                
                
                var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                
                
                directionalLight.position.set(60, 120, 50);
                scene.add(directionalLight);
                // console.log(group.children);                // 设置用于计算阴影的光源对象
                var width = window.innerWidth; //窗口宽度
                var height = window.innerHeight; //窗口高度
                var k = width / height; //窗口宽高比
                var s = 200; //三维场景显示范围控制系数，系数越大，显示的范围越大
                //创建相机对象
                var camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 0, 2000);
                camera.position.set(200, 300, 1200); //设置相机位置
                camera.lookAt(scene.position); //设置相机方向(指向的场景对象)
                /**
                * 创建渲染器对象
                */
                var renderer = new THREE.WebGLRenderer();
                renderer.setSize(width, height);//设置渲染区域尺寸
                renderer.setClearColor(0xb9d3ff, 1); //设置背景颜色
                document.body.appendChild(renderer.domElement); //body元素中插入canvas对象
                //执行渲染操作   指定场景、相机作为参数
                renderer.render(scene, camera);
                
                // console.log(controls);
                function render() {
                    renderer.render(scene,camera);//执行渲染操作
                    // mesh.translateY(1);//每次绕y轴旋转0.01弧度
                    requestAnimationFrame(render);//请求再次执行渲染函数render
                }
                render();
                var control = new THREE.OrbitControls(camera,renderer.domElement);

		</script>
	</body>
</html>